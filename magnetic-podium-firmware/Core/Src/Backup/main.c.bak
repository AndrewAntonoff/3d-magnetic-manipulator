/* USER CODE BEGIN Header */
/*
@file           : main.c
@brief          : Main program body
@attention
Copyright (c) 2024 Your Company.
All rights reserved.
This software is licensed under terms that can be found in the LICENSE file
in the root directory of this software component.
If no LICENSE file comes with this software, it is provided AS-IS.
*/
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dma.h"
#include "quadspi.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "usb_device.h"
#include "gpio.h"
#include "debug_console.h"
#include "coil_driver.h"
#include "levitation_control.h"
#include "sensor_mlx90393.h"
#include "qspi_flash.h"
#include "json_commands.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

// Структура HID отчета для джойстика
// УБРАНА: теперь определена в config.h
// #pragma pack(push, 1) // Упаковка структуры без выравнивания
// typedef struct {
//     uint8_t report_id; // 0x01 (если используется ID)
//     int16_t x;         // Signed 16-bit
//     int16_t y;         // Signed 16-bit
//     int16_t z;         // Signed 16-bit
//     int16_t rx;        // Signed 16-bit (Pitch)
//     int16_t ry;        // Signed 16-bit (Yaw)
//     int16_t rz;        // Signed 16-bit (Roll)
//     uint32_t buttons;  // 32 бит для кнопок (LSB first)
// } HID_JoystickReport_TypeDef;
// #pragma pack(pop)
typedef enum {
    WAIT_FOR_AA,
    WAIT_FOR_55,
    RECEIVING_DATA
} ImuRxState_t;

static ImuRxState_t imu_rx_state = WAIT_FOR_AA;
static uint8_t imu_temp_buf[IMU_PACKET_SIZE];
static uint8_t imu_temp_idx;

// Глобальные структуры
// Убрано определение SystemState_t, так как оно определено в config.h
// SystemState_t system_state = { ... }; // Убрано, так как определение в config.h

// Буферы
char console_buffer[256]; // Уменьшенный буфер
uint8_t command_buffer[64]; // Уменьшенный буфер команд
uint16_t command_index = 0;
uint8_t RxChar;

// Тайминги
uint32_t last_monitor_time = 0;
uint32_t last_cpu_measure = 0;
uint32_t last_stream_time = 0; // Для потоковой передачи

// Статистика
uint32_t total_commands = 0;
uint32_t idle_counter = 0;

// Флаги
uint8_t new_command = 0;
uint8_t streaming_active = 0;
uint32_t stream_interval_ms = 50;    // Интервал передачи (20 Гц)

// Глобальная переменная для отчета HID
// Определение глобальной переменной
// --- ОПРЕДЕЛЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ---

HID_JoystickReport_TypeDef Joystick_Report = {0};

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define CMD_HELP           "help"
#define CMD_STATUS         "status"
#define CMD_CALIBRATE      "calibrate"
#define CMD_SAVE_CAL       "save_cal"
#define CMD_LOAD_CAL       "load_cal"
#define CMD_SENSOR         "sensor"
#define CMD_START_STREAM   "start_stream"
#define CMD_STOP_STREAM    "stop_stream"
#define CMD_LEVITATE       "levitate"
#define CMD_STOP_LEVITATE  "stop_levitate"
#define CMD_SET_TARGET     "set_target"
#define CMD_TEST_COIL   "test_coil"
#define CMD_TEST_ALL     "test_all"
#define CMD_TEST_GROUP   "test_group"
#define CMD_STOP_TEST    "stop_test"
#define CMD_COILS_OFF    "coils_off"

/* USER CODE END PD */
#define IMU_PACKET_SIZE 22
/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

// Внешняя переменная для датчиков
extern MLX90393_t sensors[NUM_SENSORS];

/* USER CODE END PV */
extern SystemState_t system_state;
extern PID_6DOF_t pid_controller;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
/* USER CODE BEGIN PFP */

// Прототипы внутренних функций
void System_Init(void);
void Process_Console_Commands(void);
void Update_System_Status(void);
void Calculate_CPU_Usage(void);
void Update_Uptime(void);
void Show_Help_Menu(void);
void Show_System_Status(void);
void Stream_Sensor_Data(void); // Добавлено
void Error_Handler(void); // Убедитесь, что только одна реализация
/* USER CODE BEGIN PFP */
uint8_t Read_Sensor_With_Gain(uint8_t sensor_idx);
void Calibrate_Offset_Procedure(uint8_t sensor_idx);
uint8_t Read_Sensor_Calibrated(uint8_t sensor_idx);
void Save_Calibration_To_Flash(void);
void Load_Calibration_From_Flash(void);
uint8_t Quick_Read_Sensor(uint8_t sensor_idx);
uint8_t Read_Sensor(uint8_t sensor_idx);
void Calibrate_Sensors_Start(void);
void Get_Sensor_Stats_String(char *buffer, uint16_t buffer_size);
uint8_t Test_Sensor_Connection(uint8_t sensor_idx);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// Инициализация системы
void System_Init(void) {
    // Инициализация отладки (если используется)
    Debug_Init(&huart2);
    Debug_Print(LOG_LEVEL_INFO, "=== Magnetic Manipulator System Initialization ===\r\n");

    // Инициализация катушек
    Coils_Init();
    system_state.coils_enabled = 1;

    // Инициализация датчиков
    Debug_Print(LOG_LEVEL_INFO, "Initializing magnetic sensors...\r\n");
    Sensors_Init();
    system_state.sensors_enabled = 1;

    // Инициализация QSPI Flash
    if (!QSPI_Flash_Init()) {
        Debug_Print(LOG_LEVEL_ERROR, "Failed to initialize QSPI Flash!\r\n");
        // emergency_stop = 1; // Пример
    } else {
        Debug_Print(LOG_LEVEL_INFO, "QSPI Flash initialized.\r\n");
    }

    // Загрузка калибровки из Flash (через функцию в sensor_mlx90393.c)
    Debug_Print(LOG_LEVEL_INFO, "Loading calibration data...\r\n");
    Load_Calibration_From_Flash(); // Вызов заглушки

    // Запуск PWM для таймеров (если используются для катушек в будущем)
    // HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1); // Пример
    // HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
    // и т.д.

    Debug_Print(LOG_LEVEL_INFO, "System initialization complete.\r\n");
}
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART2) {
        // существующий обработчик для консоли
        // ...
    }
    else if (huart->Instance == USART3) {
        // Здесь мы получаем по одному байту, т.к. запустили Receive_IT с размером 1
        static uint8_t byte;
        // byte уже прочитан? Нет, мы его получили через аргумент? В HAL_UART_RxCpltCallback нет данных.
        // Лучше использовать HAL_UARTEx_RxEventCallback или просто запускать приём одного байта и сохранять в глобальной переменной.
    }
}
void Process_IMU_Byte(uint8_t byte)
{
    switch (imu_rx_state) {
        case WAIT_FOR_AA:
            if (byte == 0xAA) imu_rx_state = WAIT_FOR_55;
            break;
        case WAIT_FOR_55:
            if (byte == 0x55) {
                imu_rx_state = RECEIVING_DATA;
                imu_temp_idx = 0;
            } else {
                imu_rx_state = WAIT_FOR_AA; // сброс
            }
            break;
        case RECEIVING_DATA:
            imu_temp_buf[imu_temp_idx++] = byte;
            if (imu_temp_idx >= IMU_PACKET_SIZE) {
                // Пакет получен
                // Копируем в глобальную структуру (под защитой, но в прерывании лучше минимизировать)
                memcpy((void*)&last_imu_data, imu_temp_buf, IMU_PACKET_SIZE);
                imu_packet_ready = 1;
                imu_rx_state = WAIT_FOR_AA; // ждём следующий
            }
            break;
    }
}
void Update_System_Status(void) {
    Update_Uptime();
    Calculate_CPU_Usage();
    // Добавьте другие проверки статуса
}
void Check_QSPI(void) {
    uint32_t jedec_id = QSPI_Flash_ReadJEDECID();
    if (jedec_id != 0xFFFFFFFF && jedec_id != 0) {
        Debug_Print(LOG_LEVEL_INFO, "QSPI JEDEC ID: 0x%06lX (OK)\r\n", jedec_id & 0xFFFFFF);
    } else {
        Debug_Print(LOG_LEVEL_ERROR, "QSPI not responding! ID: 0x%08lX\r\n", jedec_id);
    }
}
void Calculate_CPU_Usage(void) {
    uint32_t current_time = HAL_GetTick();
    uint32_t elapsed = current_time - last_cpu_measure;
    if(elapsed >= 1000) {  // Каждую секунду
        // float total_cycles = (SystemCoreClock / 1000) * elapsed;  // Пример
        // float usage = 100.0f - ((idle_counter * 100.0f) / total_cycles);
        float usage = 0.0f; // Заглушка
        system_state.cpu_usage_percent = usage;
        // Debug_Print(LOG_LEVEL_DEBUG, "CPU usage: %.1f%%\r\n", usage); // Удалено
        idle_counter = 0;
        last_cpu_measure = current_time;
    }
}

void Update_Uptime(void) {
    system_state.system_uptime_ms = HAL_GetTick();
}

// Функция для отображения справки
void Show_Help_Menu(void) {
    Debug_Print(LOG_LEVEL_INFO, "Available commands:\r\n");
    Debug_Print(LOG_LEVEL_INFO, "help - Show this menu\r\n");
    Debug_Print(LOG_LEVEL_INFO, "status - Show system status\r\n");
    Debug_Print(LOG_LEVEL_INFO, "sensor <idx> - Read sensor data\r\n");
    Debug_Print(LOG_LEVEL_INFO, "calibrate [idx] - Calibrate sensor offset (all sensors if no index)");
    Debug_Print(LOG_LEVEL_INFO, "save_cal - Save calibration data to flash\r\n");
    Debug_Print(LOG_LEVEL_INFO, "load_cal - Load calibration data from flash\r\n");
    Debug_Print(LOG_LEVEL_INFO, "start_stream [interval_ms] - Start data streaming (default: 50 ms)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_stream - Stop data streaming\r\n");
    Debug_Print(LOG_LEVEL_INFO, "levitate - Start levitation control\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_levitate - Stop levitation control\r\n");
    Debug_Print(LOG_LEVEL_INFO, "set_target x y z - Set levitation target position\r\n");
    Debug_Print(LOG_LEVEL_INFO, "calibrate <idx> - Calibrate sensor offset (remove magnets)");
    Debug_Print(LOG_LEVEL_INFO, "read_cal <idx> - Read sensor with calibration applied");
    Debug_Print(LOG_LEVEL_INFO, "read_raw <idx> - Read raw sensor data (with gain)");
    Debug_Print(LOG_LEVEL_INFO, "test_coil <idx> <start> <end> <step> <duration_ms> - Run test on single coil\r\n");
    Debug_Print(LOG_LEVEL_INFO, "test_all <power> - Set all coils to power (-1..1)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "test_group <mask> <power> - Set coils by bit mask (hex) to power\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_test - Stop current coil test\r\n");
    Debug_Print(LOG_LEVEL_INFO, "coils_off - Turn off all coils\r\n");
}
void Show_Prompt(void) {
    HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n> ", 4, 10);
}

// Функция для отображения статуса
void Show_System_Status(void) {
    Debug_Print(LOG_LEVEL_INFO, "System status:\r\n");
    Debug_Print(LOG_LEVEL_INFO, "Uptime: %lu ms\r\n", system_state.system_uptime_ms);
    Debug_Print(LOG_LEVEL_INFO, "CPU usage: %.1f%%\r\n", system_state.cpu_usage_percent);
    Debug_Print(LOG_LEVEL_INFO, "Coils enabled: %d\r\n", system_state.coils_enabled);
    Debug_Print(LOG_LEVEL_INFO, "Sensors enabled: %d\r\n", system_state.sensors_enabled);
    Debug_Print(LOG_LEVEL_INFO, "Calibration done: %d\r\n", system_state.calibration_done);
    Debug_Print(LOG_LEVEL_INFO, "Monitoring active: %d\r\n", system_state.monitoring_active);
    Debug_Print(LOG_LEVEL_INFO, "Levitation active: %d\r\n", system_state.levitation_active);
    Debug_Print(LOG_LEVEL_INFO, "Ball position: X=%.2f, Y=%.2f, Z=%.2f\r\n", system_state.ball_position[0], system_state.ball_position[1], system_state.ball_position[2]);

    Get_Sensor_Stats_String(console_buffer, sizeof(console_buffer));
    Debug_Print(LOG_LEVEL_INFO, "%s\r\n", console_buffer);
}

void Stream_Sensor_Data(void) {
    if (!streaming_active) return;
    uint32_t current_time = HAL_GetTick();
    if (current_time - last_stream_time < stream_interval_ms) {
        return;
    }
    last_stream_time = current_time;

    char buffer[128];  // достаточно для 5*3 чисел + время
    int len = snprintf(buffer, sizeof(buffer), "%lu", current_time);

    for (int i = 0; i < ACTIVE_SENSORS; i++) {
        if (sensors[i].is_connected) {
            // Используем калиброванные значения
            float x = sensors[i].magnetic_field[0] + sensors[i].offset[0];
            float y = sensors[i].magnetic_field[1] + sensors[i].offset[1];
            float z = sensors[i].magnetic_field[2] + sensors[i].offset[2];
            len += snprintf(buffer + len, sizeof(buffer) - len, ",%.1f,%.1f,%.1f", x, y, z);
        } else {
            len += snprintf(buffer + len, sizeof(buffer) - len, ",0,0,0");
        }
    }
    len += snprintf(buffer + len, sizeof(buffer) - len, ",%.1f,%.1f,%.1f",
                    system_state.ball_position[0],
                    system_state.ball_position[1],
                    system_state.ball_position[2]);
    strcat(buffer, "\n");
    HAL_UART_Transmit(&huart2, (uint8_t*)buffer, strlen(buffer), 10);
}

// --- Заглушки для HID ---
void Calculate_3D_Position(void) {
    // Заглушка: вычисление 3D позиции/ориентации шара на основе данных с датчиков
    // и применение калибровки. Требует сложного алгоритма.
    // Пока просто заполняем нулями.
    Joystick_Report.x = 0;
    Joystick_Report.y = 0;
    Joystick_Report.z = 0;
    Joystick_Report.rx = 0;
    Joystick_Report.ry = 0;
    Joystick_Report.rz = 0;
    Joystick_Report.buttons = 0;
}

void Send_HID_Report(void) {
    // Заглушка: вызов функции отправки отчета HID
    // USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, (uint8_t*)&Joystick_Report, sizeof(Joystick_Report));
    // Реализация требует настройки USB HID
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
  HAL_Init();
  /* USER CODE END 1 */

  /* MPU Configuration--------------------------------------------------------*/
  MPU_Config();

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_SPI1_Init();
  MX_TIM1_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  MX_QUADSPI_Init();
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN 2 */

  // Инициализация системы
  System_Init();

  JSON_Init();

  // Включаем прием по UART
  HAL_UART_Receive_IT(&huart2, &RxChar, 1);

  // Запуск ШИМ для всех катушек
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);

  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);

  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);

  // Выводим приветствие
  Debug_Print(LOG_LEVEL_INFO, "\r\n");
  Debug_Print(LOG_LEVEL_INFO, "========================================\r\n");
  Debug_Print(LOG_LEVEL_INFO, "   MAGNETIC MANIPULATOR CONTROL SYSTEM\r\n");
  Debug_Print(LOG_LEVEL_INFO, "   Version: 2.0 Cleaned | Coils: %d | Sensors: %d\r\n", NUM_COILS, NUM_SENSORS);
  Debug_Print(LOG_LEVEL_INFO, "========================================\r\n\r\n");

  // Показываем помощь
  Show_Help_Menu();
  HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n> ", 4, 10);

  // Запускаем системный таймер
  last_monitor_time = HAL_GetTick();
  last_cpu_measure = HAL_GetTick();

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

    // Обработка команд
    Process_Console_Commands();
    // Периодическое обновление датчиков
        static uint32_t last_sensor_read = 0;
        uint32_t now = HAL_GetTick();
        if (now - last_sensor_read >= 20) {
            for (int i = 0; i < ACTIVE_SENSORS; i++) {
                if (sensors[i].is_connected) {
                    Read_Sensor_With_Gain(i);
                }
            }
            last_sensor_read = now;
        }
        if (imu_packet_ready) {
            imu_packet_ready = 0;
            static uint32_t last_print = 0;
            uint32_t now = HAL_GetTick();
            if (now - last_print > 1000) {
                last_print = now;
                Debug_Print(LOG_LEVEL_INFO, "IMU seq=%u r=%d p=%d y=%d\n",
                           last_imu_data.sequence,
                           last_imu_data.roll,
                           last_imu_data.pitch,
                           last_imu_data.yaw);
            }
        }
    // Потоковая передача данных (если включена)
    Stream_Sensor_Data();

    static uint32_t last_control_time = 0;
    if (system_state.levitation_active && (now - last_control_time >= 1)) {
    	EstimateBallPosition(system_state.ball_position, current_orientation);
        Apply_Levitation_Control();
        last_control_time = now;
    }

    // Обновление статуса системы
    Update_System_Status();

    // --- Заглушка для HID ---
    // static uint32_t last_hid_update = 0;
    // const uint32_t hid_interval_ms = 10; // ~100 Hz
    // if (HAL_GetTick() - last_hid_update >= hid_interval_ms) {
    //     Calculate_3D_Position();
    //     Send_HID_Report();
    //     last_hid_update = HAL_GetTick();
    // }
    // --- Конец заглушки ---
    // --- Обработка теста катушек ---
    Process_Coil_Test();   // <-- добавить эту строку
    // Небольшая задержка для стабильности
    if(!streaming_active) {
        HAL_Delay(1);
    } else {
        HAL_Delay(0); // Минимальная задержка при потоковой передаче
    }
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 64;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

void Error_Handler(void) {
    Debug_Print(LOG_LEVEL_ERROR, "Fatal error occurred! System halted.\r\n");
    // Мигаем светодиодом (если есть, например, PC13)
    while(1) {
        // HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // Пример
        HAL_Delay(500);
    }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART2) {
        if (RxChar == '\r' || RxChar == '\n') {
            if (command_index > 0) {
                new_command = 1;
            }
            HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 10);
        } else if (RxChar == '\b' || RxChar == 127) {
            if (command_index > 0) {
                command_index--;
                HAL_UART_Transmit(&huart2, (uint8_t*)"\b \b", 3, 10);
            }
        } else if (command_index < sizeof(command_buffer) - 1) {
            command_buffer[command_index++] = RxChar;
            HAL_UART_Transmit(&huart2, &RxChar, 1, 10); // эхо
        }
        HAL_UART_Receive_IT(&huart2, &RxChar, 1);
    }
}

void Process_Console_Commands(void) {
	// Проверка на JSON (строка начинается с '{')
	if (cmd_start[0] == '{') {
	    JSON_ProcessCommand(cmd_start);
	    // После обработки JSON не нужно показывать приглашение повторно?
	    // Можно просто очистить буфер и вернуться.
	    command_index = 0;
	    memset(command_buffer, 0, sizeof(command_buffer));
	    Show_Prompt();
	    return;
	}
    if (!new_command) return;
    new_command = 0;

    // Null-terminate буфер
    command_buffer[command_index] = '\0';
    total_commands++;

    // Удаляем пробельные символы в начале и конце (включая \r, \n)
    char *cmd_start = (char*)command_buffer;
    while (*cmd_start == ' ' || *cmd_start == '\t' || *cmd_start == '\r' || *cmd_start == '\n')
        cmd_start++;

    int len = strlen(cmd_start);
    while (len > 0 && (cmd_start[len-1] == ' ' || cmd_start[len-1] == '\t' ||
                        cmd_start[len-1] == '\r' || cmd_start[len-1] == '\n')) {
        cmd_start[--len] = '\0';
    }

    // Если после очистки строка пуста – просто показываем приглашение
    if (len == 0) {
        command_index = 0;
        memset(command_buffer, 0, sizeof(command_buffer));
        Show_Prompt();
        return;
    }

    // Разделяем команду и аргументы
    char *cmd = strtok(cmd_start, " ");
    if (cmd == NULL) {
        command_index = 0;
        memset(command_buffer, 0, sizeof(command_buffer));
        Show_Prompt();
        return;
    }

    // === Обработка команд ===
    if (strcmp(cmd, "help") == 0) {
        Show_Help_Menu();
    }
    else if (strcmp(cmd, "status") == 0) {
        Show_System_Status();
    }
    else if (strcmp(cmd, "coil") == 0) {
        char *idx_str = strtok(NULL, " ");
        char *pwr_str = strtok(NULL, " ");
        if (idx_str && pwr_str) {
            int idx = atoi(idx_str);
            float pwr = atof(pwr_str);
            if (idx >= 0 && idx < NUM_COILS) {
                Set_Coil_Power(idx, pwr);
            }
        }
    }
    else if (strcmp(cmd, "sensor") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: sensor <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_Calibrated(idx);  // показывает калиброванные значения
            }
        }
    }
    else if (strcmp(cmd, CMD_TEST_COIL) == 0) {
        char *idx_str = strtok(NULL, " ");
        char *start_str = strtok(NULL, " ");
        char *end_str = strtok(NULL, " ");
        char *step_str = strtok(NULL, " ");
        char *dur_str = strtok(NULL, " ");
        if (idx_str && start_str && end_str && step_str && dur_str) {
            int idx = atoi(idx_str);
            float start = atof(start_str);
            float end = atof(end_str);
            float step = atof(step_str);
            uint32_t dur = atoi(dur_str);
            if (idx >= 0 && idx < NUM_COILS) {
                // Выключаем все остальные катушки
                for (int i = 0; i < NUM_COILS; i++) {
                    if (i != idx) Set_Coil_Power(i, 0.0f);
                }
                Start_Coil_Test(idx, start, end, step, dur);
                Debug_Print(LOG_LEVEL_INFO, "Started test on coil %d\r\n", idx);
            } else {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid coil index\r\n");
            }
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_coil <idx> <start> <end> <step> <duration_ms>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_TEST_ALL) == 0) {
        char *power_str = strtok(NULL, " ");
        if (power_str) {
            float power = atof(power_str);
            Set_All_Coils_Power(power);
            Debug_Print(LOG_LEVEL_INFO, "Set all coils to %.2f\r\n", power);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_all <power>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_TEST_GROUP) == 0) {
        char *mask_str = strtok(NULL, " ");
        char *power_str = strtok(NULL, " ");
        if (mask_str && power_str) {
            uint32_t mask = strtoul(mask_str, NULL, 0);  // поддерживает hex (0x00F)
            float power = atof(power_str);
            for (int i = 0; i < NUM_COILS; i++) {
                if (mask & (1 << i)) {
                    Set_Coil_Power(i, power);
                } else {
                    Set_Coil_Power(i, 0.0f);
                }
            }
            Debug_Print(LOG_LEVEL_INFO, "Set mask 0x%X to %.2f\r\n", mask, power);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_group <mask> <power>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_STOP_TEST) == 0) {
        Stop_Coil_Test();
        Debug_Print(LOG_LEVEL_INFO, "Coil test stopped\r\n");
    }
    else if (strcmp(cmd, "read_raw") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: read_raw <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_With_Gain(idx);
            }
        }
    }
    else if (strcmp(cmd, CMD_COILS_OFF) == 0) {
        Stop_All_Coils();
        Debug_Print(LOG_LEVEL_INFO, "All coils turned off\r\n");
    }
    else if (strcmp(cmd, "read_cal") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: read_cal <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_Calibrated(idx);
            }
        }
    }
    else if (strcmp(cmd, "set_pid_pos") == 0) {
        // set_pid_pos axis Kp Ki Kd
        char *axis_str = strtok(NULL, " ");
        char *kp_str = strtok(NULL, " ");
        char *ki_str = strtok(NULL, " ");
        char *kd_str = strtok(NULL, " ");
        if (axis_str && kp_str && ki_str && kd_str) {
            int axis = atoi(axis_str); // 0:X,1:Y,2:Z
            float kp = atof(kp_str);
            float ki = atof(ki_str);
            float kd = atof(kd_str);
            if (axis >=0 && axis <3) {
                pid_controller.Kp_pos[axis] = kp;
                pid_controller.Ki_pos[axis] = ki;
                pid_controller.Kd_pos[axis] = kd;
                Debug_Print(LOG_LEVEL_INFO, "PID pos[%d] set to %f %f %f\n", axis, kp, ki, kd);
            }
        }
    }
    else if (strcmp(cmd, "set_pid_ori") == 0) {
        // аналогично для ориентации (0:roll,1:pitch,2:yaw)
    }
    else if (strcmp(cmd, "set_target") == 0) {
        // уже есть
    }
    else if (strcmp(cmd, "calibrate") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            // калибруем все датчики
            Debug_Print(LOG_LEVEL_INFO, "Calibrating all active sensors...\r\n");
            for (int i = 0; i < ACTIVE_SENSORS; i++) {
                if (sensors[i].is_connected) {
                    Calibrate_Offset_Procedure(i);
                }
            }
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Calibrate_Offset_Procedure(idx);
            }
        }
    }
    else if (strcmp(cmd, "save_cal") == 0) {
        Save_Calibration_To_Flash();
    }
    else if (strcmp(cmd, "load_cal") == 0) {
        Load_Calibration_From_Flash();
    }
    else if (strcmp(cmd, "start_stream") == 0) {
        char *arg = strtok(NULL, " ");
        if (arg) {
            int interval = atoi(arg);
            if (interval >= 10 && interval <= 1000) {
                stream_interval_ms = interval;
            }
        }
        streaming_active = 1;
        Debug_Print(LOG_LEVEL_INFO, "Streaming started (interval: %lu ms)\r\n", stream_interval_ms);
    }
    else if (strcmp(cmd, "stop_stream") == 0) {
        streaming_active = 0;
        Debug_Print(LOG_LEVEL_INFO, "Streaming stopped\r\n");
    }
    else if (strcmp(cmd, "levitate") == 0) {
        Start_Levitation();
    }
    else if (strcmp(cmd, "stop_levitate") == 0) {
        Stop_Levitation();
    }
    else if (strcmp(cmd, "set_target") == 0) {
        char *x_str = strtok(NULL, " ");
        char *y_str = strtok(NULL, " ");
        char *z_str = strtok(NULL, " ");
        if (x_str && y_str && z_str) {
            float x = atof(x_str);
            float y = atof(y_str);
            float z = atof(z_str);
            Set_Levitation_Target(x, y, z);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: set_target x y z\r\n");
        }
    }
    else {
        Debug_Print(LOG_LEVEL_ERROR, "Unknown command: '%s'\r\n", cmd);
        Debug_Print(LOG_LEVEL_INFO, "Try 'help' for available commands\r\n");
    }

    // Сброс буфера и вывод приглашения
    command_index = 0;
    memset(command_buffer, 0, sizeof(command_buffer));
    Show_Prompt();
}


/* USER CODE END 4 */

 /* MPU Configuration */

void MPU_Config(void)
{
  MPU_Region_InitTypeDef MPU_InitStruct = {0};

  /* Disables the MPU */
  HAL_MPU_Disable();

  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress = 0x0;
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);

}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
