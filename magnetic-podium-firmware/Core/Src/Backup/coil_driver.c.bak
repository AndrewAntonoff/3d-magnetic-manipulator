#include "coil_driver.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

// Массив катушек
Coil_t coils[NUM_COILS];
CoilTest_t coil_test = {0};

void Coils_Init(void) {
    // Инициализация всех катушек
    for(int i = 0; i < NUM_COILS; i++) {
        coils[i].current_pwm = 0.0f;
        coils[i].target_pwm = 0.0f;
        coils[i].enabled_time_ms = 0;
        coils[i].is_faulty = 0;
        coils[i].total_on_time_ms = 0;
        coils[i].activation_count = 0;
        memset(coils[i].fault_reason, 0, sizeof(coils[i].fault_reason));
    }
}

void Set_Coil_Power(uint8_t coil_idx, float power) {
    if(coil_idx >= NUM_COILS) return;

    // Ограничение мощности
    if(power > 1.0f) power = 1.0f;
    if(power < -1.0f) power = -1.0f;

    coils[coil_idx].current_pwm = power;
    coils[coil_idx].target_pwm = power;

    // Здесь должна быть реальная установка PWM через HAL
    // Например: __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, (uint32_t)(power * PWM_MAX_VALUE));
}

void Set_All_Coils_Power(float power) {
    for(int i = 0; i < NUM_COILS; i++) {
        Set_Coil_Power(i, power);
    }
}

void Stop_All_Coils(void) {
    Set_All_Coils_Power(0.0f);
}

float Get_Coil_Power(uint8_t coil_idx) {
    if(coil_idx >= NUM_COILS) return 0.0f;
    return coils[coil_idx].current_pwm;
}

void Start_Coil_Test(uint8_t coil_idx, float start_pwm, float end_pwm,
                     float step, uint32_t step_duration) {
    coil_test.coil_index = coil_idx;
    coil_test.test_pwm_start = start_pwm;
    coil_test.test_pwm_end = end_pwm;
    coil_test.test_pwm_step = step;
    coil_test.step_duration_ms = step_duration;
    coil_test.test_in_progress = 1;
    coil_test.test_start_time = HAL_GetTick();
    coil_test.steps_completed = 0;
}

void Stop_Coil_Test(void) {
    coil_test.test_in_progress = 0;
}

void Process_Coil_Test(void) {
    if(!coil_test.test_in_progress) return;

    uint32_t current_time = HAL_GetTick();
    uint32_t elapsed = current_time - coil_test.test_start_time;

    // Расчет текущего шага
    uint32_t current_step = elapsed / coil_test.step_duration_ms;

    if(current_step > coil_test.steps_completed) {
        float current_pwm = coil_test.test_pwm_start +
                           (coil_test.test_pwm_step * current_step);

        if((coil_test.test_pwm_step > 0 && current_pwm <= coil_test.test_pwm_end) ||
           (coil_test.test_pwm_step < 0 && current_pwm >= coil_test.test_pwm_end)) {
            Set_Coil_Power(coil_test.coil_index, current_pwm);
            coil_test.steps_completed = current_step;
        } else {
            Stop_Coil_Test();
            Set_Coil_Power(coil_test.coil_index, 0.0f);
        }
    }
}

uint8_t Is_Coil_Test_Running(void) {
    return coil_test.test_in_progress;
}

void Check_Coils_Safety(void) {
    // Проверка безопасности катушек
    for(int i = 0; i < NUM_COILS; i++) {
        // Проверка на перегрев, перегрузку и т.д.
        if(fabs(coils[i].current_pwm) > 0.8f) {
            // Если мощность слишком высокая
            if(!coils[i].is_faulty) {
                coils[i].is_faulty = 1;
                strcpy(coils[i].fault_reason, "Overpower");
            }
        } else {
            if(coils[i].is_faulty && strcmp(coils[i].fault_reason, "Overpower") == 0) {
                coils[i].is_faulty = 0;
            }
        }
    }
}

void Reset_Coil_Fault(uint8_t coil_idx) {
    if(coil_idx < NUM_COILS) {
        coils[coil_idx].is_faulty = 0;
        memset(coils[coil_idx].fault_reason, 0, sizeof(coils[coil_idx].fault_reason));
    }
}

uint8_t Get_Coil_Fault_Status(uint8_t coil_idx) {
    if(coil_idx >= NUM_COILS) return 0;
    return coils[coil_idx].is_faulty;
}

const char* Get_Coil_Fault_Reason(uint8_t coil_idx) {
    if(coil_idx >= NUM_COILS) return "";
    return coils[coil_idx].fault_reason;
}

void Get_Coils_Status_String(char* buffer, uint16_t buffer_size) {
    snprintf(buffer, buffer_size, "Coils: ");
    for(int i = 0; i < NUM_COILS; i++) {
        char temp[16];
        snprintf(temp, sizeof(temp), "%.2f ", coils[i].current_pwm);
        strcat(buffer, temp);
    }
}

float Get_Coils_Average_Power(void) {
    float sum = 0.0f;
    for(int i = 0; i < NUM_COILS; i++) {
        sum += fabs(coils[i].current_pwm);
    }
    return sum / NUM_COILS;
}

float Get_Coils_Max_Power(void) {
    float max_power = 0.0f;
    for(int i = 0; i < NUM_COILS; i++) {
        float power = fabs(coils[i].current_pwm);
        if(power > max_power) {
            max_power = power;
        }
    }
    return max_power;
}

uint32_t Get_Coils_Total_On_Time(void) {
    uint32_t total = 0;
    for(int i = 0; i < NUM_COILS; i++) {
        total += coils[i].total_on_time_ms;
    }
    return total;
}
