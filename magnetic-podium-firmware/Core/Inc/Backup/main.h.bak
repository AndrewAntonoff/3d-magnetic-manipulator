/* USER CODE BEGIN Header */
/*
@file           : main.c
@brief          : Main program body
@attention
Copyright (c) 2024 Your Company.
All rights reserved.
This software is licensed under terms that can be found in the LICENSE file
in the root directory of this software component.
If no LICENSE file comes with this software, it is provided AS-IS.
*/
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dma.h"
#include "quadspi.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "usb_device.h"
#include "gpio.h"
#include "debug_console.h"
#include "coil_driver.h"
#include "levitation_control.h"
#include "sensor_mlx90393.h"
#include "qspi_flash.h"
#include "json_commands.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

typedef enum {
    WAIT_FOR_AA,
    WAIT_FOR_55,
    RECEIVING_DATA
} ImuRxState_t;

static ImuRxState_t imu_rx_state = WAIT_FOR_AA;
static uint8_t imu_temp_buf[IMU_PACKET_SIZE];
static uint8_t imu_temp_idx;

// FIX: Определяем глобальные переменные для IMU (они объявлены как extern в main.h)
volatile IMU_Data_t last_imu_data;
volatile uint8_t imu_packet_ready = 0;

// Буферы
char console_buffer[256];
uint8_t command_buffer[64];
uint16_t command_index = 0;
uint8_t RxChar;

// Тайминги
uint32_t last_monitor_time = 0;
uint32_t last_cpu_measure = 0;
uint32_t last_stream_time = 0;

// Статистика
uint32_t total_commands = 0;
uint32_t idle_counter = 0;

// Флаги
uint8_t new_command = 0;
uint8_t streaming_active = 0;
uint32_t stream_interval_ms = 50;

// Глобальная переменная для отчета HID
HID_JoystickReport_TypeDef Joystick_Report = {0};

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define CMD_HELP           "help"
#define CMD_STATUS         "status"
#define CMD_CALIBRATE      "calibrate"
#define CMD_SAVE_CAL       "save_cal"
#define CMD_LOAD_CAL       "load_cal"
#define CMD_SENSOR         "sensor"
#define CMD_START_STREAM   "start_stream"
#define CMD_STOP_STREAM    "stop_stream"
#define CMD_LEVITATE       "levitate"
#define CMD_STOP_LEVITATE  "stop_levitate"
#define CMD_SET_TARGET     "set_target"
#define CMD_TEST_COIL      "test_coil"
#define CMD_TEST_ALL       "test_all"
#define CMD_TEST_GROUP     "test_group"
#define CMD_STOP_TEST      "stop_test"
#define CMD_COILS_OFF      "coils_off"
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

// Внешняя переменная для датчиков
extern MLX90393_t sensors[NUM_SENSORS];

/* USER CODE END PV */

// FIX: Объявляем внешние переменные из других модулей
extern SystemState_t system_state;
extern PID_6DOF_t pid_controller;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
/* USER CODE BEGIN PFP */

// Прототипы внутренних функций
void System_Init(void);
void Process_Console_Commands(void);
void Update_System_Status(void);
void Calculate_CPU_Usage(void);
void Update_Uptime(void);
void Show_Help_Menu(void);
void Show_System_Status(void);
void Stream_Sensor_Data(void);
void Error_Handler(void);
void Process_IMU_Byte(uint8_t byte);
uint8_t Read_Sensor_With_Gain(uint8_t sensor_idx);
void Calibrate_Offset_Procedure(uint8_t sensor_idx);
uint8_t Read_Sensor_Calibrated(uint8_t sensor_idx);
void Save_Calibration_To_Flash(void);
void Load_Calibration_From_Flash(void);
uint8_t Quick_Read_Sensor(uint8_t sensor_idx);
uint8_t Read_Sensor(uint8_t sensor_idx);
void Calibrate_Sensors_Start(void);
void Get_Sensor_Stats_String(char *buffer, uint16_t buffer_size);
uint8_t Test_Sensor_Connection(uint8_t sensor_idx);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// Инициализация системы
void System_Init(void) {
    Debug_Init(&huart2);
    Debug_Print(LOG_LEVEL_INFO, "=== Magnetic Manipulator System Initialization ===\r\n");

    Coils_Init();
    system_state.coils_enabled = 1;

    Debug_Print(LOG_LEVEL_INFO, "Initializing magnetic sensors...\r\n");
    Sensors_Init();
    system_state.sensors_enabled = 1;

    if (!QSPI_Flash_Init()) {
        Debug_Print(LOG_LEVEL_ERROR, "Failed to initialize QSPI Flash!\r\n");
    } else {
        Debug_Print(LOG_LEVEL_INFO, "QSPI Flash initialized.\r\n");
    }

    Debug_Print(LOG_LEVEL_INFO, "Loading calibration data...\r\n");
    Load_Calibration_From_Flash();

    Debug_Print(LOG_LEVEL_INFO, "System initialization complete.\r\n");
}

// FIX: Убрали второй обработчик HAL_UART_RxCpltCallback, оставим один позже
// Пока убираем этот блок (он дублируется)

void Process_IMU_Byte(uint8_t byte)
{
    switch (imu_rx_state) {
        case WAIT_FOR_AA:
            if (byte == 0xAA) imu_rx_state = WAIT_FOR_55;
            break;
        case WAIT_FOR_55:
            if (byte == 0x55) {
                imu_rx_state = RECEIVING_DATA;
                imu_temp_idx = 0;
            } else {
                imu_rx_state = WAIT_FOR_AA;
            }
            break;
        case RECEIVING_DATA:
            imu_temp_buf[imu_temp_idx++] = byte;
            if (imu_temp_idx >= IMU_PACKET_SIZE) {
                memcpy((void*)&last_imu_data, imu_temp_buf, IMU_PACKET_SIZE);
                imu_packet_ready = 1;
                imu_rx_state = WAIT_FOR_AA;
            }
            break;
    }
}

void Update_System_Status(void) {
    Update_Uptime();
    Calculate_CPU_Usage();
}

void Check_QSPI(void) {
    uint32_t jedec_id = QSPI_Flash_ReadJEDECID();
    if (jedec_id != 0xFFFFFFFF && jedec_id != 0) {
        Debug_Print(LOG_LEVEL_INFO, "QSPI JEDEC ID: 0x%06lX (OK)\r\n", jedec_id & 0xFFFFFF);
    } else {
        Debug_Print(LOG_LEVEL_ERROR, "QSPI not responding! ID: 0x%08lX\r\n", jedec_id);
    }
}

void Calculate_CPU_Usage(void) {
    uint32_t current_time = HAL_GetTick();
    uint32_t elapsed = current_time - last_cpu_measure;
    if(elapsed >= 1000) {
        float usage = 0.0f; // Заглушка
        system_state.cpu_usage_percent = usage;
        idle_counter = 0;
        last_cpu_measure = current_time;
    }
}

void Update_Uptime(void) {
    system_state.system_uptime_ms = HAL_GetTick();
}

void Show_Help_Menu(void) {
    Debug_Print(LOG_LEVEL_INFO, "Available commands:\r\n");
    Debug_Print(LOG_LEVEL_INFO, "help - Show this menu\r\n");
    Debug_Print(LOG_LEVEL_INFO, "status - Show system status\r\n");
    Debug_Print(LOG_LEVEL_INFO, "sensor <idx> - Read sensor data\r\n");
    Debug_Print(LOG_LEVEL_INFO, "calibrate [idx] - Calibrate sensor offset (all sensors if no index)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "save_cal - Save calibration data to flash\r\n");
    Debug_Print(LOG_LEVEL_INFO, "load_cal - Load calibration data from flash\r\n");
    Debug_Print(LOG_LEVEL_INFO, "start_stream [interval_ms] - Start data streaming (default: 50 ms)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_stream - Stop data streaming\r\n");
    Debug_Print(LOG_LEVEL_INFO, "levitate - Start levitation control\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_levitate - Stop levitation control\r\n");
    Debug_Print(LOG_LEVEL_INFO, "set_target x y z - Set levitation target position\r\n");
    Debug_Print(LOG_LEVEL_INFO, "read_cal <idx> - Read sensor with calibration applied\r\n");
    Debug_Print(LOG_LEVEL_INFO, "read_raw <idx> - Read raw sensor data (with gain)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "test_coil <idx> <start> <end> <step> <duration_ms> - Run test on single coil\r\n");
    Debug_Print(LOG_LEVEL_INFO, "test_all <power> - Set all coils to power (-1..1)\r\n");
    Debug_Print(LOG_LEVEL_INFO, "test_group <mask> <power> - Set coils by bit mask (hex) to power\r\n");
    Debug_Print(LOG_LEVEL_INFO, "stop_test - Stop current coil test\r\n");
    Debug_Print(LOG_LEVEL_INFO, "coils_off - Turn off all coils\r\n");
}

void Show_Prompt(void) {
    HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n> ", 4, 10);
}

void Show_System_Status(void) {
    Debug_Print(LOG_LEVEL_INFO, "System status:\r\n");
    Debug_Print(LOG_LEVEL_INFO, "Uptime: %lu ms\r\n", system_state.system_uptime_ms);
    Debug_Print(LOG_LEVEL_INFO, "CPU usage: %.1f%%\r\n", system_state.cpu_usage_percent);
    Debug_Print(LOG_LEVEL_INFO, "Coils enabled: %d\r\n", system_state.coils_enabled);
    Debug_Print(LOG_LEVEL_INFO, "Sensors enabled: %d\r\n", system_state.sensors_enabled);
    Debug_Print(LOG_LEVEL_INFO, "Calibration done: %d\r\n", system_state.calibration_done);
    Debug_Print(LOG_LEVEL_INFO, "Monitoring active: %d\r\n", system_state.monitoring_active);
    Debug_Print(LOG_LEVEL_INFO, "Levitation active: %d\r\n", system_state.levitation_active);
    Debug_Print(LOG_LEVEL_INFO, "Ball position: X=%.2f, Y=%.2f, Z=%.2f\r\n",
                system_state.ball_position[0], system_state.ball_position[1], system_state.ball_position[2]);

    Get_Sensor_Stats_String(console_buffer, sizeof(console_buffer));
    Debug_Print(LOG_LEVEL_INFO, "%s\r\n", console_buffer);
}

void Stream_Sensor_Data(void) {
    if (!streaming_active) return;
    uint32_t current_time = HAL_GetTick();
    if (current_time - last_stream_time < stream_interval_ms) {
        return;
    }
    last_stream_time = current_time;

    char buffer[128];
    int len = snprintf(buffer, sizeof(buffer), "%lu", current_time);

    for (int i = 0; i < ACTIVE_SENSORS; i++) {
        if (sensors[i].is_connected) {
            float x = sensors[i].magnetic_field[0] + sensors[i].offset[0];
            float y = sensors[i].magnetic_field[1] + sensors[i].offset[1];
            float z = sensors[i].magnetic_field[2] + sensors[i].offset[2];
            len += snprintf(buffer + len, sizeof(buffer) - len, ",%.1f,%.1f,%.1f", x, y, z);
        } else {
            len += snprintf(buffer + len, sizeof(buffer) - len, ",0,0,0");
        }
    }
    len += snprintf(buffer + len, sizeof(buffer) - len, ",%.1f,%.1f,%.1f",
                    system_state.ball_position[0],
                    system_state.ball_position[1],
                    system_state.ball_position[2]);
    strcat(buffer, "\n");
    HAL_UART_Transmit(&huart2, (uint8_t*)buffer, strlen(buffer), 10);
}

void Calculate_3D_Position(void) {
    Joystick_Report.x = 0;
    Joystick_Report.y = 0;
    Joystick_Report.z = 0;
    Joystick_Report.rx = 0;
    Joystick_Report.ry = 0;
    Joystick_Report.rz = 0;
    Joystick_Report.buttons = 0;
}

void Send_HID_Report(void) {
    // Заглушка
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  HAL_Init();

  MPU_Config();

  HAL_Init();

  SystemClock_Config();

  MX_GPIO_Init();
  MX_DMA_Init();
  MX_SPI1_Init();
  MX_TIM1_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  MX_QUADSPI_Init();
  MX_USB_DEVICE_Init();

  /* USER CODE BEGIN 2 */

  System_Init();
  JSON_Init();

  HAL_UART_Receive_IT(&huart2, &RxChar, 1);

  // Запуск ШИМ для всех катушек
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);

  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);

  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);

  Debug_Print(LOG_LEVEL_INFO, "\r\n");
  Debug_Print(LOG_LEVEL_INFO, "========================================\r\n");
  Debug_Print(LOG_LEVEL_INFO, "   MAGNETIC MANIPULATOR CONTROL SYSTEM\r\n");
  Debug_Print(LOG_LEVEL_INFO, "   Version: 2.0 Cleaned | Coils: %d | Sensors: %d\r\n", NUM_COILS, NUM_SENSORS);
  Debug_Print(LOG_LEVEL_INFO, "========================================\r\n\r\n");

  Show_Help_Menu();
  HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n> ", 4, 10);

  last_monitor_time = HAL_GetTick();
  last_cpu_measure = HAL_GetTick();

  /* USER CODE END 2 */

  while (1)
  {
    uint32_t now = HAL_GetTick();

    Process_Console_Commands();

    static uint32_t last_sensor_read = 0;
    if (now - last_sensor_read >= 20) {
        for (int i = 0; i < ACTIVE_SENSORS; i++) {
            if (sensors[i].is_connected) {
                Read_Sensor_With_Gain(i);
            }
        }
        last_sensor_read = now;
    }

    if (imu_packet_ready) {
        imu_packet_ready = 0;
        static uint32_t last_print = 0;
        if (now - last_print > 1000) {
            last_print = now;
            Debug_Print(LOG_LEVEL_INFO, "IMU seq=%u r=%d p=%d y=%d\n",
                       last_imu_data.sequence,
                       last_imu_data.roll,
                       last_imu_data.pitch,
                       last_imu_data.yaw);
        }
    }

    Stream_Sensor_Data();

    static uint32_t last_control_time = 0;
    if (system_state.levitation_active && (now - last_control_time >= 1)) {
        // FIX: Определяем массив для ориентации (пока нулевой)
        float current_orientation[4] = {1.0f, 0.0f, 0.0f, 0.0f}; // единичный кватернион
        EstimateBallPosition(system_state.ball_position, current_orientation);
        Apply_Levitation_Control();
        last_control_time = now;
    }

    Update_System_Status();

    Process_Coil_Test();

    if(!streaming_active) {
        HAL_Delay(1);
    } else {
        HAL_Delay(0);
    }
  }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 64;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

// FIX: ЕДИНСТВЕННЫЙ обработчик UART (объединяем USART2 и USART3)
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART2) {
        if (RxChar == '\r' || RxChar == '\n') {
            if (command_index > 0) {
                new_command = 1;
            }
            HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 10);
        } else if (RxChar == '\b' || RxChar == 127) {
            if (command_index > 0) {
                command_index--;
                HAL_UART_Transmit(&huart2, (uint8_t*)"\b \b", 3, 10);
            }
        } else if (command_index < sizeof(command_buffer) - 1) {
            command_buffer[command_index++] = RxChar;
            HAL_UART_Transmit(&huart2, &RxChar, 1, 10);
        }
        HAL_UART_Receive_IT(&huart2, &RxChar, 1);
    }
    // Для USART3 обработка будет в прерывании (вызов Process_IMU_Byte), здесь не требуется
}

// FIX: ЕДИНСТВЕННЫЙ Error_Handler
void Error_Handler(void) {
    Debug_Print(LOG_LEVEL_ERROR, "Fatal error occurred! System halted.\r\n");
    while(1) {
        HAL_Delay(500);
    }
}

void Process_Console_Commands(void) {
    if (!new_command) return;
    new_command = 0;

    command_buffer[command_index] = '\0';
    total_commands++;

    // Удаляем пробелы в начале и конце
    char *cmd_start = (char*)command_buffer;
    while (*cmd_start == ' ' || *cmd_start == '\t' || *cmd_start == '\r' || *cmd_start == '\n')
        cmd_start++;

    int len = strlen(cmd_start);
    while (len > 0 && (cmd_start[len-1] == ' ' || cmd_start[len-1] == '\t' ||
                        cmd_start[len-1] == '\r' || cmd_start[len-1] == '\n')) {
        cmd_start[--len] = '\0';
    }

    if (len == 0) {
        command_index = 0;
        memset(command_buffer, 0, sizeof(command_buffer));
        Show_Prompt();
        return;
    }

    // FIX: Проверка на JSON должна быть здесь, после получения cmd_start
    if (cmd_start[0] == '{') {
        JSON_ProcessCommand(cmd_start);
        command_index = 0;
        memset(command_buffer, 0, sizeof(command_buffer));
        Show_Prompt();
        return;
    }

    char *cmd = strtok(cmd_start, " ");
    if (cmd == NULL) {
        command_index = 0;
        memset(command_buffer, 0, sizeof(command_buffer));
        Show_Prompt();
        return;
    }

    if (strcmp(cmd, "help") == 0) {
        Show_Help_Menu();
    }
    else if (strcmp(cmd, "status") == 0) {
        Show_System_Status();
    }
    else if (strcmp(cmd, "coil") == 0) {
        char *idx_str = strtok(NULL, " ");
        char *pwr_str = strtok(NULL, " ");
        if (idx_str && pwr_str) {
            int idx = atoi(idx_str);
            float pwr = atof(pwr_str);
            if (idx >= 0 && idx < NUM_COILS) {
                Set_Coil_Power(idx, pwr);
            }
        }
    }
    else if (strcmp(cmd, "sensor") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: sensor <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_Calibrated(idx);
            }
        }
    }
    else if (strcmp(cmd, CMD_TEST_COIL) == 0) {
        char *idx_str = strtok(NULL, " ");
        char *start_str = strtok(NULL, " ");
        char *end_str = strtok(NULL, " ");
        char *step_str = strtok(NULL, " ");
        char *dur_str = strtok(NULL, " ");
        if (idx_str && start_str && end_str && step_str && dur_str) {
            int idx = atoi(idx_str);
            float start = atof(start_str);
            float end = atof(end_str);
            float step = atof(step_str);
            uint32_t dur = atoi(dur_str);
            if (idx >= 0 && idx < NUM_COILS) {
                for (int i = 0; i < NUM_COILS; i++) {
                    if (i != idx) Set_Coil_Power(i, 0.0f);
                }
                Start_Coil_Test(idx, start, end, step, dur);
                Debug_Print(LOG_LEVEL_INFO, "Started test on coil %d\r\n", idx);
            } else {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid coil index\r\n");
            }
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_coil <idx> <start> <end> <step> <duration_ms>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_TEST_ALL) == 0) {
        char *power_str = strtok(NULL, " ");
        if (power_str) {
            float power = atof(power_str);
            Set_All_Coils_Power(power);
            Debug_Print(LOG_LEVEL_INFO, "Set all coils to %.2f\r\n", power);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_all <power>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_TEST_GROUP) == 0) {
        char *mask_str = strtok(NULL, " ");
        char *power_str = strtok(NULL, " ");
        if (mask_str && power_str) {
            uint32_t mask = strtoul(mask_str, NULL, 0);
            float power = atof(power_str);
            for (int i = 0; i < NUM_COILS; i++) {
                if (mask & (1 << i)) {
                    Set_Coil_Power(i, power);
                } else {
                    Set_Coil_Power(i, 0.0f);
                }
            }
            Debug_Print(LOG_LEVEL_INFO, "Set mask 0x%X to %.2f\r\n", mask, power);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: test_group <mask> <power>\r\n");
        }
    }
    else if (strcmp(cmd, CMD_STOP_TEST) == 0) {
        Stop_Coil_Test();
        Debug_Print(LOG_LEVEL_INFO, "Coil test stopped\r\n");
    }
    else if (strcmp(cmd, "read_raw") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: read_raw <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_With_Gain(idx);
            }
        }
    }
    else if (strcmp(cmd, CMD_COILS_OFF) == 0) {
        Stop_All_Coils();
        Debug_Print(LOG_LEVEL_INFO, "All coils turned off\r\n");
    }
    else if (strcmp(cmd, "read_cal") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: read_cal <idx>\r\n");
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Read_Sensor_Calibrated(idx);
            }
        }
    }
    else if (strcmp(cmd, "set_pid_pos") == 0) {
        char *axis_str = strtok(NULL, " ");
        char *kp_str = strtok(NULL, " ");
        char *ki_str = strtok(NULL, " ");
        char *kd_str = strtok(NULL, " ");
        if (axis_str && kp_str && ki_str && kd_str) {
            int axis = atoi(axis_str);
            float kp = atof(kp_str);
            float ki = atof(ki_str);
            float kd = atof(kd_str);
            if (axis >=0 && axis <3) {
                pid_controller.Kp_pos[axis] = kp;
                pid_controller.Ki_pos[axis] = ki;
                pid_controller.Kd_pos[axis] = kd;
                Debug_Print(LOG_LEVEL_INFO, "PID pos[%d] set to %f %f %f\n", axis, kp, ki, kd);
            }
        }
    }
    else if (strcmp(cmd, "set_pid_ori") == 0) {
        // TODO: добавить аналогично
    }
    else if (strcmp(cmd, "calibrate") == 0) {
        char *arg = strtok(NULL, " ");
        if (!arg) {
            Debug_Print(LOG_LEVEL_INFO, "Calibrating all active sensors...\r\n");
            for (int i = 0; i < ACTIVE_SENSORS; i++) {
                if (sensors[i].is_connected) {
                    Calibrate_Offset_Procedure(i);
                }
            }
        } else {
            int idx = atoi(arg);
            if (idx < 0 || idx >= NUM_SENSORS) {
                Debug_Print(LOG_LEVEL_ERROR, "Invalid sensor index\r\n");
            } else {
                Calibrate_Offset_Procedure(idx);
            }
        }
    }
    else if (strcmp(cmd, "save_cal") == 0) {
        Save_Calibration_To_Flash();
    }
    else if (strcmp(cmd, "load_cal") == 0) {
        Load_Calibration_From_Flash();
    }
    else if (strcmp(cmd, "start_stream") == 0) {
        char *arg = strtok(NULL, " ");
        if (arg) {
            int interval = atoi(arg);
            if (interval >= 10 && interval <= 1000) {
                stream_interval_ms = interval;
            }
        }
        streaming_active = 1;
        Debug_Print(LOG_LEVEL_INFO, "Streaming started (interval: %lu ms)\r\n", stream_interval_ms);
    }
    else if (strcmp(cmd, "stop_stream") == 0) {
        streaming_active = 0;
        Debug_Print(LOG_LEVEL_INFO, "Streaming stopped\r\n");
    }
    else if (strcmp(cmd, "levitate") == 0) {
        Start_Levitation();
    }
    else if (strcmp(cmd, "stop_levitate") == 0) {
        Stop_Levitation();
    }
    else if (strcmp(cmd, "set_target") == 0) {
        char *x_str = strtok(NULL, " ");
        char *y_str = strtok(NULL, " ");
        char *z_str = strtok(NULL, " ");
        if (x_str && y_str && z_str) {
            float x = atof(x_str);
            float y = atof(y_str);
            float z = atof(z_str);
            Set_Levitation_Target(x, y, z);
        } else {
            Debug_Print(LOG_LEVEL_ERROR, "Usage: set_target x y z\r\n");
        }
    }
    else {
        Debug_Print(LOG_LEVEL_ERROR, "Unknown command: '%s'\r\n", cmd);
        Debug_Print(LOG_LEVEL_INFO, "Try 'help' for available commands\r\n");
    }

    command_index = 0;
    memset(command_buffer, 0, sizeof(command_buffer));
    Show_Prompt();
}
/* USER CODE END 4 */

/* MPU Configuration */
void MPU_Config(void)
{
  MPU_Region_InitTypeDef MPU_InitStruct = {0};

  HAL_MPU_Disable();

  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress = 0x0;
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}
